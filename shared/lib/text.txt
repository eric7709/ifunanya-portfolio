1. What are the main tasks a compiler must perform?
 _Answer:
 A compiler must:
 1. Check the syntax and semantics of the source program for correctness.
 2. Generate correct and efficient object code.
 3. Handle run-time organization (memory layout, storage allocation).
 4. Format output according to assembler and linker conventions_.


2. Name and briefly describe the three main parts of a compiler.
 Answer:
 -Frontend: Checks syntax and semantics, reports errors, performs type checking, and generates an intermediate representation (IR).
 -Middle-end: Performs optimizations on the IR (e.g., dead code elimination, loop optimization, constant propagation).
 -Backend: Generates target machine code from the optimized IR.


3. What is the role of the frontend in a compiler?
 Answer:
 The frontend checks whether the program is syntactically and semantically correct, reports errors, performs type checking, and produces an intermediate representation (IR) for further processing.


4. What happens in the middle-end of a compiler?
 _Answer:
 The middle-end performs _optimizations_ on the intermediate representation. Examples include:
 - Removing unreachable or useless code.
 - Constant propagation and folding.
 - Loop optimization (e.g., code motion).
 - Specialization of computations.
   It then passes the optimized IR to the backend.


5. What is the purpose of the backend in a compiler?
 _Answer:
 The backend takes the optimized IR from the middle-end and generates _target machine code_ (assembly or binary) that can be executed on hardware.


6. Define _intermediate representation (IR)_ and explain its importance.
 _Answer:
 An intermediate representation (IR) is a machine-independent code structure generated by the frontend. It allows for easier analysis and optimization before producing machine code. It serves as a bridge between the frontend and backend.


7. List three examples of optimizations performed in the middle-end.
 _Answer:
 - Dead code elimination (removing unreachable code).
 - Constant folding (replacing expressions with constant values).
 - Loop-invariant code motion (moving calculations outside loops).


8. Why is error reporting important in the frontend?
 _Answer:
 Error reporting helps programmers identify and fix syntax and semantic errors in their code. A good compiler provides clear, useful error messages to make debugging easier.


9. How does a compiler ensure that generated code is efficient?
 _Answer:
 Efficiency is achieved mainly in the _middle-end_ through optimizations and in the _backend_ through register allocation, instruction selection, and target-specific code improvements.


10. What is the relationship between frontend, middle-end, and backend?
 _Answer:
 - The _frontend_ produces IR from source code.
 - The _middle-end_ optimizes this IR.
 - The _backend_ converts the optimized IR into machine code.
   They work in sequence: source code → frontend → middle-end → backend → target code.

The Output of an assembler is called an Object file, which contains a combination of machine instructions as well as the data required to place these instrucnitons in memory 









































































Emeka Eric
1:43 AM (0 minutes ago)
to me

﻿
Here’s a clean, exam-ready set of *questions and answers* based on your notes:

### 1. What is semantic analysis, and what does it do?
*Answer:*
Semantic analysis is the third phase of a compiler. It checks that the parse tree follows language rules — like type compatibility, undeclared variables, and proper use of identifiers. It produces an *annotated syntax tree* and ensures declarations and statements are semantically correct.

### 2. What are the main functions of semantic analysis?
*Answer:*
- *Type Checking:* Ensures operations use compatible data types.
- *Label Checking:* Verifies all referenced labels exist.
- *Flow Control Check:* Ensures control structures (like `break` statements) are used correctly.

### 3. What are common semantic errors?
*Answer:*
- Type mismatch
- Undeclared variables
- Misuse of reserved identifiers

### 4. What is intermediate code generation?
*Answer:*
It’s the phase after semantic analysis where the compiler translates the source code into an *intermediate representation (IR)* — a machine-independent code that’s easier to optimize and translate into target machine code.

### 5. Why is intermediate code useful?
*Answer:*
- Allows one front-end for many machines.
- Makes it easier to apply optimizations.
- Separates machine-independent analysis from machine-dependent code generation.

### 6. What are the types of intermediate code representation?
*Answer:*
- *High-Level IR:* Close to source code, easy to read and modify.
- *Low-Level IR:* Close to machine code, good for register allocation and instruction selection.
- *Three-Address Code:* A common form, with at most three addresses per instruction. Can be represented as *quadruples*, *triples*, or *indirect triples*.

### 7. What is three-address code, and how is it represented?
*Answer:*
Three-address code breaks expressions into simple instructions with at most three operands.
- *Quadruples:* (operator, arg1, arg2, result)
- *Triples:* (operator, arg1, arg2) — result stored by position.
- *Indirect Triples:* Use pointers to results, making optimization easier.

### 8. What is code optimization, and what are its rules?
*Answer:*
Optimization improves intermediate code to use fewer resources (CPU, memory) and run faster without changing program meaning.
Rules:
- Must preserve program meaning.
- Should improve speed or resource usage.
- Should itself be efficient.

### 9. At what levels can optimization happen?
*Answer:*
- Source code level (better algorithms).
- Intermediate code level (loop improvement, address calculations).
- Target code level (register usage, memory hierarchy).

### 10. What happens in code generation?
*Answer:*
The compiler maps optimized intermediate code to target machine code (often assembly). It handles instruction selection, register allocation, and instruction ordering to produce efficient, correct object code.

### 11. What are register and address descriptors?
*Answer:*
- *Register Descriptor:* Tracks which values are held in each register.
- *Address Descriptor:* Tracks where variables’ values are stored (registers, memory, stack, etc.).

### 12. What is the role of the symbol table?
*Answer:*
It stores all identifiers and their attributes (type, scope, etc.), helping with type checking, scope resolution, and quick lookup during compilation.

### 13. What does an error handler do?
*Answer:*
It detects and reports errors at each phase — lexical, syntax, semantic — and tries to continue compilation to find as many errors as possible.

### 14. How are regular expressions used in lexical analysis?
*Answer:*
Regular expressions define patterns for tokens (keywords, identifiers, numbers). Lexical analyzers use them to recognize and classify tokens in the source code.

### 15. How is an identifier defined using regular expressions?
*Answer:*
- `letter = [a-zA-Z]`
- `digit = [0-9]`
- `identifier = letter (letter | digit)*`
So, an identifier starts with a letter, followed by any number of letters or digits.




















A grammar is a set of production rules which are used to generate strings of a language.


PARSING
A parser is a compiler or interpreter component that breaks data into smaller elements for easy translation into another language. 